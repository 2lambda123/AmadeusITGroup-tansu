<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@amadeus-it-group/tansu](./tansu.md) &gt; [computed](./tansu.computed.md)

## computed() function

Creates a store whose value is computed by the provided function.

**Signature:**

```typescript
export declare function computed<T>(fn: () => T, options?: Omit<StoreOptions<T>, 'onUse'>): ReadableSignal<T>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fn | () =&gt; T | computation function that returns the value of the store |
|  options | Omit&lt;[StoreOptions](./tansu.storeoptions.md)<!-- -->&lt;T&gt;, 'onUse'&gt; | _(Optional)_ store options |

**Returns:**

[ReadableSignal](./tansu.readablesignal.md)<!-- -->&lt;T&gt;

store containing the value returned by the computation function

## Remarks

The computation function is first called the first time the store is used. It can use the value of other stores or observables and the computation function is called again if the value of those dependencies changed, as long as the store is still used. Dependencies are detected automatically as the computation function gets their value either by calling the stores as a function (as it is possible with stores implementing [ReadableSignal](./tansu.readablesignal.md)<!-- -->), or by calling the [get](./tansu.get.md) function (with a store or any observable). If some calls made by the function should not be tracked as dependencies, it is possible to wrap them in a call to [untrack](./tansu.untrack.md)<!-- -->. Note that dependencies can change between calls of the computation function. Internally, tansu will subscribe to new dependencies when they are used and unsubscribe from dependencies that are no longer used after the call of the computation function.

